# Escultor 3D em C++

## Descri√ß√£o üìé

<p align = "justify">
Esse projeto consiste na cria√ß√£o de um escultor 3D interativo que gera figuras baseadas em cubos, criando s√≥lidos similares a algo visto no jogo *minecraft*. O c√≥digo desse projeto √© desenvolvido inteiramenta em <b>C++</b> utilizarando primariamente o estilo de programa√ß√£o orientado a objeto(POO). O projeto desenvolveu uma lingua simples para cria√ß√£o de s√≥lidos, pode ser visto na pasta <a href="https://github.com/LuigiVanin/3D-Sculptor/tree/main/scripts">./scripts/</a>.
<p>

<p align = "justify">
Al√©m da linguagem de programa√ß√£o C++, outras ferramentas para a vizualiza√ß√£o das figuras geradas devem ser utilizadas, as recomenda√ß√µes s√£o o <b>geomview</b> ou <b>meshlab</b>. Os softwares previamente citados foram escolhidos, pois possuem a capacidade de ler e representar arquivos do tipo <b>.OFF</b> que √© o tipo de arquivo utilizado para se armazenar os s√≥lidos feitos pelo programa em C++.

<p align = "justify">
O tipo de arquivo .OFF √© muito importante para esse projeto, pois ele √© um arquivo que pode ser escrito de uma forma padronizada de maneira a ser poss√≠vel a se denhar um solido 3D.

<br>

<p align="center">
  <img src= "./assets/ezgif.com-gif-maker.gif" height = 350/ width = 350>
</p>

## Estrutura üì¶

<p align = "justify">
O c√≥digo √© fragmentado em dois diret√≥rios principais e um c√≥digo "main.cpp". Os diret√≥tios s√£o respons√°veis por armazenas os cabe√ßalhos e classes C++. No main podemos utilizar os recursos dos diretorios "include" e "src" que s√£o as duas pastas principais. Os diret√≥rios utilizados s√£o os seguintes:
<p>

-   **include** - ret√©m os caba√ßalhos(.hpp) da classe Sculptor e do Struct Voxel. A classe Sculptor √© definido no arquivo Sculptor.cpp.

-   **src** - possui o c√≥digo da l√≥gica e implementa√ß√£o da classe Sculptor.

-   **models** - pasta para armazenar os modelos .off gerados pelo programa.

-   **scripts** - pasta referente aos scripts para a constru√ß√£o de modelos 3d.
    _OBS.: vale salientar o diret√≥rio "models" que ret√©m as figuras 3D geradas._

## Requisitos ‚ùó

-   Git
-   GCC ~> 9.4.0
-   CMake ~> 3.16.3
-   Ubuntu

_OBS.:_ **O c√≥digo pode facilmente rodar em outros sistemas**, por√©m s√≥ testei em meu ambiente, logo, n√£o posso garantir nenhuma compatibilidade

## Como baixar e rodar üöÄ

<p align="center">
  <img src= "./assets/execute.gif" height = "450px">
</p>

## Como funciona ‚ùì

#### - Cabe√ßalhos

<p align = "justify">
 O escultor 3D ser√°, basicamente, uma matriz tridimensional a qual cada um de seus espa√ßos cont√©m um objeto do tipo "Voxel" que √© uma representa√ß√£o de uma unidade de epa√ßo 3D similar ao pixel no espa√ßo 2D. A struct respectiva ao Voxel possui os atributos de cor RGB dados na forma de float e uma booleana que diz se o respectivo voxel est√° s√≥lido ou n√£o. Abaixo o c√≥digo para o voxel:
 </p>

```cpp
struct Voxel {
  float r,g,b; // Cores
  float a; // traspar√™ncia

  bool isOn; // solidez do voxel
};
```

<p align = "justify">
Al√©m da estrutura do voxels temos tamb√©m a classe Sculptor que √© respons√°vel por construir o nossos canvas de desenhos e de criar as nossas figuras. Na Nessa classe teremos um atributo que ser√° repectivo ao campo de desenho, sendo esse atributo uma matriz 3D do tipo Voxel. Al√©m de atributos, temos m√©todos que tem o trabalho de desenhar formas geom√©tricas, m√©todos que escolhem a cor do s√≥lido que ser√° desenhado e um m√©todo que escreve o arquivo .OFF. A baixo temos o c√≥digo do cabe√ßalho da classe Sculptor:
</p>

```cpp
class Sculptor {
protected:

    int nx,ny,nz; // Dimens√µes do canvas
    float r,g,b,alfa; // Cores de desenho
public:
    Voxel ***v;// Matriz 3D de voxels

    Sculptor(int _nx = 1, int _ny = 1, int _nz = 1);
    ~Sculptor();

    void alocaMemoria();

    void setColor(float r_, float g_, float b_, float alpha_);

    // M√©todos de desenho
    void putVoxel(int x, int y, int z);
    void cutVoxel(int x, int y, int z);
    void putBox(int x0, int y0, int z0, int l, int h, int w);
    void cutBox(int x0, int y0, int z0, int l, int h, int w);
    void putDisc(int xcenter, int ycenter, int zcenter, int r, int h, int axis = 1);
    void cutDisc(int xcenter, int ycenter, int zcenter, int r, int h, int axis = 1);
    void putSphere(int xcenter, int ycenter, int zcenter, int r);
    void cutSphere(int xcenter, int ycenter, int zcenter, int r);
    void putEllipsoid(int xcenter, int ycenter, int zcenter, int rx, int ry, int rz);
    void cutEllipsoid(int xcenter, int ycenter, int zcenter, int rx, int ry, int rz);

    //M√©todo que escreve o arquivo OFF de acordo com a matriz v
    void writeOFF(char* filename);
};
```

#### - Scripts C++

<p align = "justify">
Os scripts em c++ se resumem na cria√ß√£o da classe "Sculptor" que est√° no caminho "src/Sculptor.cpp" em que todos os m√©todos vistos no cabe√ßalho "include/Sculptor.hpp". Esses m√©todos de desenho se encarregam de criar formas geom√©tricas a partir de cubos(Voxels). A seguir um breve sum√°rio das fun√ß√µes criadas:
</p>

1. `putVoxel(int x, int y, int z)` : o m√©todo modifica os atributos dos voxels da matriz tridimensional `v`(atributo da classe Sculptor analoga a posi√ß√£o no espa√ßo de desenho). O m√©todo modifica o valor de `v[x][y][z]`, mudando seus atributos **rgba** e mudando o atributo **isOn** para **_true_**, tornando o voxel da posi√ß√£o x, y e z como s√≥lido. _Possui o retorno vazio_(void).

<br>

2. `cutVoxel(int x, int y, int z)` : o m√©todo, assim como o anterior, modifica os atributos dos voxels da matriz tridimensional `v`. O m√©todo modifica o valor de `v[x][y][z]`, mudando o atributo **isOn** para **_false_**, tornando o voxel da posi√ß√£o x, y e z de s√≥lido para invis√≠vel(apagando), por isso se chama de "corta voxel". _Possui o retorno vazio_(void).

<br>

3. `void putBox(int x0, int y0, int z0, int l, int h, int w)` : m√©todo em quest√£o se encarrega de construir uma figura inteira ao inv√™s de apenas colocar um voxel no canvas, a fun√ß√£o **putBox()** constroi uma caixa(prisma de base retangular) a partir de coordenadas passadas como par√¢metro at√© uma certa extens√£o em todos os eixos. Essa fun√ß√£o usa o **putVoxel()** para construir cada unidade de sua caixa. O retorno √© zero(void).

<br>

4. `void cutBox(int x0, int y0, int z0, int l, int h, int w)` : O m√©todo **cutBox()** realiza a atividade contr√°ria do m√©todo **putBox()**, pois ao inv√™s de criar uma caixa a partir de uma determinada coordenada ela corta uma caixa, retirando os voxels que pertencem a esse intervalo. Esse m√©todo usa a fun√ß√£o interna **cutVoxel()**. O retorno da fun√ß√£o √© vazio.

<br>

5. `void putSphere(int x0, int y0, int z0, int r)` : A fun√ß√£o **putSphere()** tenta construir uma esfera no canvas de desenho utilizando a equa√ß√£o da esfera de maneira computacional. Vale salientar que essa esfera √© feita de forma "quadriculada", pois a unidade de desenho, voxel, √© em forma de cubo, logo n√£o teremos a contru√ß√£o de uma esfera perfeita. O m√©todo usa a fun√ß√£o **putVoxel()**. o retorno √© vazio(void).

<br>

6. `void cutSphere(int x0, int y0, int z0, int r)` : A fun√ß√£o **cutSphere()** realiza um corte na forma de uma esfera utilizando a mesma l√≥gica computacional da fun√ß√£o **putSphere()**, por√©m usando o m√©todo **cutVoxel()** ao inv√™s da fun√ß√£o **putVoxel()**, dessa maneira gerando a retirada de voxels em um padr√£o esferico. Vale salientar que n√£o temos uma esfera perfeita, pois a unidade 3D √© c√∫bica. O retorno √© vazio(void).

<br>

7. `putEllipsoid (int xcenter, int ycenter, int zcenter, int rx, int ry, int rz)` : O m√©todo **putEllipsoid** consiste na constru√ß√£o de uma ellipisoide(representa√ß√£o 3D de uma ellipse) a partir da fun√ß√£o **putVoxel()**. Para realizar essa tarefa se utiliza a equa√ß√£o do elipsoide de forma computacioanl. Vale salientar que essa elipsoide n√£o √© perfeita pois usa como padr√£o os voxels. O retorno da fun√ß√£o √© vazio(void).

<br>

8. `cutEllipsoid (int xcenter, int ycenter, int zcenter, int rx, int ry, int rz)` : O m√©todo **cutEllipsoid** consiste no recorde de voxels no padr√£o de uma elipisoide(representa√ß√£o 3D de uma ellipse) a partir da fun√ß√£o **cutVoxel()**. Para realizar essa tarefa se utiliza a equa√ß√£o do elipsoide de forma computacioanl. Vale salientar que essa elipsoide n√£o √© perfeita pois usa como padr√£o os voxels. O retorno da fun√ß√£o √© vazio(void).
